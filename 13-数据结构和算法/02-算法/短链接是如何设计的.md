通过发号策略,每一个过来的长地址,发一个号牌即可,小型系统直接用MySQL的自增索引,大型应用,可以考虑分布式key-value系统做发号器,不停的自增即可



在数据库中并不需要存储62进制,存10进制就可以,比如拿到第10000个长地址,短地址对应的编号为9999,从数据库拿到之后,代码中做10进制转62进制的转换

#### 如何保证同一个长地址,每次转出都是同样的短地址

上面发号策略中,是不判断长地址是否已转过,所以造成结果就是一长对多短,有人说浪费空间,建立一个长对短的map存储即可,但是用map存储本身就是浪费大量空间,甚至是用大空间换小空间,这就要考虑是否真有必要做一一对应,不能一对多;

最简单方案:建一个长对短的map,空间换空间,

更好的方案:用map存储"最近"生成的长对短关系,一小时过期机制实现LRU淘汰