了解一下 php变量的内部存储结构, 即`zval`的结构体

这个是php5.3~php5.6的版本. php7做了比较大的改动(暂时先不表述)

```c
struct _zval_struct {
	union {
		long lval;
		double dval;
		struct {
			char *val;
			int len;
		} str;
		HashTable *ht;
		zend_object_value obj;
		zend_ast *ast;
	} value;					//变量value值
	zend_uint refcount__gc;   //引用计数内存中使用次数，为0删除该变量
	zend_uchar type;		   //变量类型
	zend_uchar is_ref__gc;    //区分是否是引用变量
};

```

从上面结构体内容可以看出每一个php变量都会由`变量类型`、`value值`、`引用计数次数`和`是否是引用变量`四部分组成

## 变量容器

### 非array和object变量

每次将常量赋值给一个变量时，都会产生一个变量容器

```php
$a = '宗琦的技术成长之路';
xdebug_debug_zval('a')

```

```php
a: (refcount=1, is_ref=0)='宗琦的技术成长之路'
```

### array和object变量

会产生元素个数+1的变量容器

```php
$b = [
'name' => '许铮的技术成长之路',
'number' => 3
];
xdebug_debug_zval('b')

```

```php
b: (refcount=1, is_ref=0)=array ('name' => (refcount=1, is_ref=0)='宗琦的技术成长之路', 'number' => (refcount=1, is_ref=0)=3)

```

## 赋值原理（写时复制技术）

解了常量赋值之后，接下来我们从内存角度思考变量之间的赋值

```php
$a = [
'name' => '许铮的技术成长之路',
'number' => 3
]; //创建一个变量容器，变量a指向给变量容器，a的ref_count为1
$b = $a; //变量b也指向变量a指向的变量容器，a和b的ref_count为2
xdebug_debug_zval('a', 'b');
$b['name'] = '宗琦的技术成长之路1';//变量b的其中一个元素发生改变，此时会复制出一个新的变量容器，变量b重新指向新的变量容器，a和b的ref_count变成1
xdebug_debug_zval('a', 'b'); 

```

```php
a: (refcount=2, is_ref=0)=array ('name' => (refcount=1, is_ref=0)='宗琦的技术成长之路', 'number' => (refcount=1, is_ref=0)=3)
b: (refcount=2, is_ref=0)=array ('name' => (refcount=1, is_ref=0)='宗琦的技术成长之路', 'number' => (refcount=1, is_ref=0)=3)
a: (refcount=1, is_ref=0)=array ('name' => (refcount=1, is_ref=0)='宗琦的技术成长之路', 'number' => (refcount=1, is_ref=0)=3)
b: (refcount=1, is_ref=0)=array ('name' => (refcount=1, is_ref=0)='宗琦的技术成长之路1', 'number' => (refcount=1, is_ref=0)=3)

```

所以，当变量`a`赋值给变量`b`的时候，并没有立刻生成一个新的变量容器，而是将变量`b`指向了变量`a`指向的变量容器，即`内存"共享"`；而当变量`b`其中一个元素发生改变时，才会真正发生变量容器复制，这就是`写时复制技术`

## 引用计数清0

当变量容器的`ref_count`计数清0时，表示该变量容器就会被销毁，实现了内存回收



