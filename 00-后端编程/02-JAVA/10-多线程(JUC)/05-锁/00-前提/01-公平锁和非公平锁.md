## 公平锁

是指多个线程按照申请锁的时间先后顺序来获取锁，类似于排队，FIFO规则 (非常公平， 不能够插队，必须先来后到)

## 非公平锁

 是指在多线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获到锁，在高并发的情况下，有可能造成优先级反转或者饥饿现象。[非常不公平，可以插队 （默认都是非公平）]

默认 **非公平锁** ，非公平锁的优点在于吞吐量比公平锁大，就` synchronized` 而言，它是一种**非公平锁**。



非 公 平 主 要 表 现 在 获 取 锁 的 行 为 上 ， 并 非 是 按 照 申 请 锁 的 时 间 前 后 给 等
待 线 程 分 配 锁 的 ， 每 当 锁 被 释 放 后 ， 任 何 一 个 线 程 都 有 机 会 竞 争 到 锁 ，
这 样 做 的 目 的 是 为 了 提 高 执 行 性 能 ， 缺 点 是 可 能 会 产 生 线 程 饥 饿 现 象 。

![](https://youpaiyun.zongqilive.cn/image/20200422102800.png)

## 两者的区别：

**公平锁：** 就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中抽取到自己。 

**非公平锁：** 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁的那种方式。



```java
public class MyRunnable implements Runnable {
  private int total = 10;

  // 创建 ReentrantLock对象
  Lock l = new ReentrantLock();

  @Override
  public void run() {
    while (true) {
      // 加锁
      l.lock();
      try {
        if (total > 0) {
          System.out.println("正在卖出票: " + total);
          total--;
        }
      } finally {
        // 最好放到 finally 中释放锁
        l.unlock();
      }

    }
  }

}
```

















