同步代码块在编译后会在前后分别插入`monitorenter`和`monitorexit`指令，每个对象在同一时刻只会与一个monitor相关联，当线程执行到monitorenter指令时就会尝试获取对象所对应的monitor的所有权，如果这个monitor已经被其他线程获取，则需要等待锁释放。



#### 代码块同步

```java
inal Object lock = new Object();
    public int subtr(int i){
        synchronized (lock){
            return i-1;
        }
    }
```

字节码:

![](https://youpaiyun.zongqilive.cn/image/20200711170008.png)



可以看出，monitorenter指令是在编译后插入到同步代码块的开始位置，monitorexit插入到同步代码块结束的地方，正常情况下monitorenter和monitorexit是一对一的匹配，而后面又出现了一个monitorexit，是因为那里是异常处，用来保证方法执行异常的时候，可以自动释放锁，而不会造成死锁。



#### 方法同步

```java
public synchronized int add(int i){
        return i+1;
    }
```

字节码:

![](https://youpaiyun.zongqilive.cn/image/20200711170157.png)

从字节码里也看不到monitorenter和monitorexit，只能发现flags那里，多了一个`ACC_SYNCHRONIZED`的标示

