![](https://ae01.alicdn.com/kf/H330e1e0ac8e348428e41717e597e68ff1.jpg)



![](https://pic.superbed.cn/item/5e081c1676085c32893029bd.jpg)



## float(4字节, 32位) 比 long(8字节, 64位) 范围大

long整型数，在内存中占用8个字节共64位

float在内存中占4个字节，共32位，公式: `V=(-1)^s * M * 2^E`

浮点数的32位不是简单的直接表示大小，而是按照一定的标准分配的。

​		其中第1位，符号位，即S。

　　接下来的8位，指数域，即E。

　　剩下的23位，小数域，即M，M的取值范围为[1，2）或[0，1）。

也就是说，浮点数在内存中的二进制值不是直接转换为十进制数值的，而是按照上述公式计算而来，通过这个公式，虽然只用到了4个字节，但是浮点数却比长整型的最大值要大。

指数位8位代表0~255，根据IEEE 754规定，0代表0,255代表无穷大，剩下1~254，每个减去127，代表-126~127这个指数范围，也就是说float的幂级数大致范围是2的-126次幂到127次幂之间，而long是8个字节，也就是64位，除去符号位，范围在只有2的63次幂，远远小于float。




## long和double字节数都是8，也就是64bits, 为什么double大呢?

 首先浮点类型分单精度float和双精度double    

而他们的底层存储结构不同：他们是由`符号位`，`指数位`，`尾数位`组成。

> 1.符号位：最高位31，表示浮点数的正负，0为正，1为负；
>
> 2.指数位：占的位数代表着该类型的范围，例如`float`指数位范围第30-23位(占8bit)，则范围为2^8-1等同于-128~128
>
> 3.尾数位：占的位数代表着精度，也就是小数点后面的尾数
>
> 	float的尾数：
> 	23位，其范围为：0~2^23，而2^23=8388608=106.92，
> 	所以float的精度为6~7位，能保证6位为绝对精确，7位一般也是正确的，8位就不一定了（但不是说8位就绝对不对了）
> 	
> 	double的尾数：
> 	52位，2^52=2.220446049250313E-16，最小是16位，但最小不是1.0E-16，所以精度是15~16，能保证15，一般16位。

```
种类------符号位-------------指数位----------------尾数位---- 
float---第31位(占1bit)---第30-23位(占8bit)----第22-0位(占23bit) 
double--第63位(占1bit)---第62-52位(占11bit)---第51-0位(占52bit) 
```























