## `TIME_WAIT`状态及其优化

为什么 `TIME_WAIT`状态需要保持`2MSL`？因为这可以保证至少一次报文的往返时间内，端口是不可复用的。

假设 `TIME_WAIT`状态的持续时间很短，我们来模拟下面这种场景：

- 客户端向服务器端发送了三条报文，其中第3条报文卡在网络中，服务器只收到了前两条，向客户单发送ACK=2，客户端重新发送第三条报文。
- 服务器主动发送FIN报文，客户端收到后发送FIN、ACK，服务器端收到后发送ACK并进入 `TIME_WAIT`状态（假设这个状态很短）。
- 现在服务器又再次和客户端建立连接，三次握手之后开始发送正常数据，结果之前卡住的第三条报文，现在终于发送到服务器，但服务器也不知道该如何处理这条报文。

因此这也是 `TIME_WAIT`状态需要保持2MSL的原因，如果这么长时间也没有收到报文，即使有正确的报文从客户端发出，也已经过期了，因此不会影响到之后的通信。



但这同样也会带来一个问题， `TIME_WAIT`状态保持的时间较长，假设服务器端有大量 `TIME_WAIT`状态的TCP连接，就相当于白白浪费掉大量的服务器资源(端口)。此时，我们可以通过修改以下配置进行服务器调优：

```
net.ipv4.tcp_tw_reuse = 1
```

- 开启后，作为客户端时新连接可以使用仍然处于 `TIME_WAIT`状态的端口
- 由于timestamp的存在，操作系统可以拒绝迟到的报文（例如上面说的第三条报文），可以利用以下配置：

```
net.ipv4.tcp_timestamps = 1
```







## 为什么需要TIME_WAIT

 **是谁有TIME_WAIT状态呢？为什么？**

​        **执行主动关闭的那一端、因为可能不得不重传最终那个ACK的就是这一端**

**TIME_WAIT有多久呢？**

​        **最长分节生命期的两倍。2MSL。MSL:任何IP数据报能够在因特网上存活的最长时间**, 通常为 2分钟

 **什么是迷途的重复分组呢？**

**假设迷途的分组是一个TCP分节，他在迷途期间，发送端TCP超时并重传该分组，而重传的分组却通过某条候选路径到达最终目的地。然后不久后（自迷途的分组开始其迷途旅程起最多MSL）路由循环修复，早先迷失的分组最终也被送到目的地。这样的分组就叫迷途重复分组。**



**TIME_WAIT存在的理由：**

1) 确保这段时间内不会创建具有相同地址和端口的新连接.

2）可靠地实现TCP全双工连接的终止
    在进行关闭连接四路握手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，服务器将重发最终的FIN，因此客户端必须维护状态信息允 许它重发最终的ACK.

3）允许老的重复分节在网络中消逝  
    TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个 原来的迷途分节就称为lost duplicate。在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，后一个连接被称为前一个连接的化身 （incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免这个情 况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时 候，来自连接先前化身的重复分组已经在网络中消逝。



## 大量TIME_WAIT的解决办法

## 增加负载机器

### 修改MSL的时间

​	修改MSL的时间，Linux的MSL默认是60s，2个MSL就是2分钟，所以系统默认的time_wait时间很长，但是该参数需要修改Linux的内存并进行重新编译，一般不建议采用这种方案。



### 调整ulimit的参数，调整TCP参数

​	linux默认的open files值为1024（当前进程可打开的openfiles数），可以调大该参数值。

```
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 30
```

**tcp_tw_recycle**为可用于快速回收处于TIME_WAIT状态的socket以便重新分配，设置为1 即开启 ；

  **tcp_tw_reuse设置为 1，即** 开启该选项后，kernel会复用处于TIME_WAIT状态的socket，当然复用的前提是“从协议角度来看，复用是安全的”。

 修改结束后sysctl –p 既可以使内核生效。







