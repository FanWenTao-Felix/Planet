![](https://ae01.alicdn.com/kf/He0e5342981924689a8382c2562326b33O.jpg)







```sql
//Session A
START TRANSACTION;
UPDATE account SET p_money=p_money-100 WHERE p_name="tim";
UPDATE account SET p_money=p_money+100 WHERE p_name="bill";
COMMIT;
//Thread B
START TRANSACTION;
UPDATE account SET p_money=p_money+100 WHERE p_name="bill";
UPDATE account SET p_money=p_money-100 WHERE p_name="tim";
COMMIT;
```

当线程A执行到第一条语句`UPDATE account SET p_money=p_money-100 WHERE p_name=”tim”`;锁定了`p_name=”tim”`的行数据；并且试图获取`p_name=”bill”`的数据；

此时，恰好，线程B也执行到第一条语句：`UPDATE account SET p_money=p_money+100 WHERE p_name=”bill”;`锁定了` p_name=”bill”`的数据，同时试图获取`p_name=”tim”`的数据； 
此时，两个线程就进入了死锁，谁也无法获取自己想要获取的资源，进入无线等待中，直到超时！

## 解决方案

1. 修改隔离级别为提交读（RC）
2. 修改业务代码逻辑，删除记录之前，先select，确认该记录存在，再执行delete删除该记录。



## 如何尽可能避免死锁

1）以固定的顺序访问表和行。比如两个更新数据的事务，事务A 更新数据的顺序 为1，2；事务B更新数据的顺序为2，1。这样更可能会造成死锁。

2）大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。

3）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。

4）降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。

5）为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。







