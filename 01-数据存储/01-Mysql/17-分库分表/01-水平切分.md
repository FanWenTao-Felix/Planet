当业务难以更细粒度地进行垂直切分，或者切分后单表数据依然过大，存在单库读写、存储性能瓶颈时候，这时候就可以考虑水平切分了。

## 库内分表

库内分表就是在同一个db上，将表按照某种条件拆分为多张表。

比如一张订单表，我们可以依据订单的日期，按月建表。一月份的订单放month_201901这张表，二月份的订单放month_201902这张表。库内分表只解决单表数据量过大问题，但没有将表分布到不同机器上，所有请求还是在一台物理机上竞争cpu，内存，IO，对于减轻mysql负载压力来说帮助不大。



## 分库分表

分库分表就是将表不仅拆分，而且拆分到不同机器上。

可以指定一张表的shardKey，然后对shardKey取hash，根据hash值将数据放到不同的数据库中。这个可以解决单机物理资源的瓶颈问题。

下边示例先根据业务耦合性垂直分库，然后再针对单个库进行分库分表。

![eKsECT.png](https://s2.ax1x.com/2019/07/27/eKsECT.png)

## 分库分表优缺点

**优点：**

1. 不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力

2. 应用端改造较小，不需要拆分业务模块

**缺点：**

1. 跨分片的事务一致性较难保障，一般需要一层中间件，介于业务和db之间。

2. 跨库的join关联查询性能较差



## 分表策略

### Range--按范围划分

，比如我们可以将某张表的创建时间按照日期划分存为月表；也可以将某张表的主键按照范围划分，比如 【1~10000】在一张表，【10001~20000】在一张表，以此类推。

### Hash

这里的 `hash` 便是将我们需要分表的字段进行一次散列运算，使得经过散列的数据尽可能的均匀并且不重复。

当然如果本身这个字段就是一个整形并且不重复也可以省略这个步骤，直接进行 `Mod` 得到分表下标即可



### Range + Hash

![](https://ae01.alicdn.com/kf/H0cb5d3db865b426185985a02053a74d1W.jpg)



## 分表数量选择

分表数量（64）也是有讲究的.但是这个数量又不是瞎选的，和 `HashMap` 一样，也建议得是 `2^n`，这样可以方便在扩容的时尽可能的少迁移数据。



