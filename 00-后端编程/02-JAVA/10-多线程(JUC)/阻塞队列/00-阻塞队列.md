![](https://youpaiyun.zongqilive.cn/image/20200307115755.png)

![](https://youpaiyun.zongqilive.cn/image/20200307115814.png)

```
一种队列，它还支持在检索元素时等待队列变为非空，在存储元素时等待队列中的空间变为可用的操作。BlockingQueue方法有四种形式，其处理操作的方式不同，不能立即满足，但可能在将来某个时候满足：一种方法抛出异常，另一种方法返回特殊值（根据操作的不同，可以为null或false），第三个在操作成功之前无限期阻塞当前线程，第四个在放弃之前仅阻塞给定的最大时间限制。
```

![](https://youpaiyun.zongqilive.cn/image/20200307115845.png)

![](https://youpaiyun.zongqilive.cn/image/20200307115906.png)

什么情况下，我们会使用阻塞队列：多线程并发处理，线程池

![](https://youpaiyun.zongqilive.cn/image/20200307115937.png)

```java
public class Test {
  public static void main(String[] args) throws InterruptedException {
    test4();
  }
  /**
     * 抛出异常
     */
  public static void test1(){
    // 队列的大小
    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

    System.out.println(blockingQueue.add("a"));
    System.out.println(blockingQueue.add("b"));
    System.out.println(blockingQueue.add("c"));
    // IllegalStateException: Queue full 抛出异常！
    // System.out.println(blockingQueue.add("d"));

    System.out.println("=-===========");

    System.out.println(blockingQueue.element()); // 查看队首元素是谁
    System.out.println(blockingQueue.remove());


    System.out.println(blockingQueue.remove());
    System.out.println(blockingQueue.remove());

    // java.util.NoSuchElementException 抛出异常！
    // System.out.println(blockingQueue.remove());
  }

  /**
     * 有返回值，没有异常
     */
  public static void test2(){
    // 队列的大小
    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

    System.out.println(blockingQueue.offer("a"));
    System.out.println(blockingQueue.offer("b"));
    System.out.println(blockingQueue.offer("c"));

    System.out.println(blockingQueue.peek());
    // System.out.println(blockingQueue.offer("d")); // false 不抛出异常！
    System.out.println("============================");
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll()); // null  不抛出异常！
  }

  /**
     * 等待，阻塞（一直阻塞）
     */
  public static void test3() throws InterruptedException {
    // 队列的大小
    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

    // 一直阻塞
    blockingQueue.put("a");
    blockingQueue.put("b");
    blockingQueue.put("c");
    // blockingQueue.put("d"); // 队列没有位置了，一直阻塞
    System.out.println(blockingQueue.take());
    System.out.println(blockingQueue.take());
    System.out.println(blockingQueue.take());
    System.out.println(blockingQueue.take()); // 没有这个元素，一直阻塞

  }

  /**
     * 等待，阻塞（等待超时）
     */
  public static void test4() throws InterruptedException {
    // 队列的大小
    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);

    blockingQueue.offer("a");
    blockingQueue.offer("b");
    blockingQueue.offer("c");
    // blockingQueue.offer("d",2,TimeUnit.SECONDS); // 等待超过2秒就退出
    System.out.println("===============");
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll());
    blockingQueue.poll(2,TimeUnit.SECONDS); // 等待超过2秒就退出

  }
}
```













