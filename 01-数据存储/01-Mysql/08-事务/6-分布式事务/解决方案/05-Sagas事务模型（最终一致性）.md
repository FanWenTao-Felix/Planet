Saga模式是一种分布式异步事务，一种最终一致性事务，是一种柔性事务，有两种不同的方式来实现saga事务，最流行的两种方式是：



**一、 事件/编排Choreography：没有中央协调器（没有单点风险）时，每个服务产生并聆听其他服务的事件，并决定是否应采取行动。**



该实现第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件，当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。

![](https://ae01.alicdn.com/kf/Hb5702426d41448c2873da5a9a3720832h.png)

**处理流程：**

1. 订单服务保存新订单，将状态设置为pengding挂起状态，并发布名为ORDER_CREATED_EVENT的事件。
2. 支付服务监听ORDER_CREATED_EVENT，并公布事件BILLED_ORDER_EVENT。
3. 库存服务监听BILLED_ORDER_EVENT，更新库存，并发布ORDER_PREPARED_EVENT。
4. 货运服务监听ORDER_PREPARED_EVENT，然后交付产品。最后，它发布ORDER_DELIVERED_EVENT。
5. 最后，订单服务侦听ORDER_DELIVERED_EVENT并设置订单的状态为concluded完成。



假设库存服务在事务过程中失败了。进行回滚：

1. 库存服务产生PRODUCT_OUT_OF_STOCK_EVENT

2. 订购服务和支付服务会监听到上面库存服务的这一事件：

   ①支付服务会退款给客户。

   ②订单服务将订单状态设置为失败。



**优点：**事件/编排是实现Saga模式的自然方式; 它很简单，容易理解，不需要太多的努力来构建，所有参与者都是松散耦合的，因为他们彼此之间没有直接的耦合。如果您的事务涉及2至4个步骤，则可能是非常合适的。



**二、 命令/协调orchestrator：中央协调器负责集中处理事件的决策和业务逻辑排序。**



saga协调器orchestrator以命令/回复的方式与每项服务进行通信，告诉他们应该执行哪些操作。

![](https://ae01.alicdn.com/kf/H78397d38fbbf41f4b7f4826c35361b14Z.png)



1. 订单服务保存pending状态，并要求订单Saga协调器（简称OSO）开始启动订单事务。
2. OSO向收款服务发送执行收款命令，收款服务回复Payment Executed消息。
3. OSO向库存服务发送准备订单命令，库存服务将回复OrderPrepared消息。
4. OSO向货运服务发送订单发货命令，货运服务将回复Order Delivered消息。



OSO订单Saga协调器必须事先知道执行“创建订单”事务所需的流程(通过读取BPM业务流程XML配置获得)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。当你有一个中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。

**优点：**

- 避免服务之间的循环依赖关系，因为saga协调器会调用saga参与者，但参与者不会调用协调器。
- 集中分布式事务的编排。
- 只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。
- 在添加新步骤时，事务复杂性保持线性，回滚更容易管理。
- 如果在第一笔交易还没有执行完，想改变有第二笔事务的目标对象，则可以轻松地将其暂停在协调器上，直到第一笔交易结束。



**缺点：**协调器中集中太多逻辑的风险。



















