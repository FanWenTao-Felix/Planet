https://jwt.io/

JWT包含三部分数据：

通常有` HEADER (头)`，`PAYLOAD (有效载荷)`和 `SIGNATURE (签名)`三个部分组成，三者之间使用`“.”`链接，格式如下：

```
header.payload.signature
```

## Header: 头部

标头用于存储有关如何计算JWT签名的信息，如对象类型，签名算法等.

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

type 表示该对象为 JWT,

alg 表示创建 JWT 时使用HMAC-SHA256 散列算法计算签名。



## Payload：载荷

有效载荷主要用于存储用户信息，如用户 ID，Email，角色和权限信息等。

```json
{
  "uid":1234,
  "role":"admin",
  "name":"zongqi"
}
```

## Signature：签名

签名则需要使用 Base64URL 编码技术对标头 (Header 和有效载荷(Payload) 进行编码，并作为参数和秘钥一同传递给签名算法，生成最终的签名 (Signature)。

以 HMAC-SHA256 算法为例，下面是生成签名的一个伪代码：

![](https://ae01.alicdn.com/kf/He1f6f44a21f346b683d0b02400316341C.jpg)



![](https://ae01.alicdn.com/kf/H27b3a78fcd904671bf1492c6935c8ab2A.jpg)

![](https://ae01.alicdn.com/kf/Hf28253d13d5f4df7a9d076cb1ff3a879g.jpg)



## 优势

### 更少的数据库连接

因其基于算法来实现身份认证，在使用 JWT 时查询数据的次数更少(更少的数据连接不等于不连接数据库)，可以获得更快的系统响应时间。构建更简单：如果你的应用程序本身是无状态的，那么选择 JWT 可以加快系统构建过程。

### 跨服务调用

构建一个认证中心来处理用户身份认证和发放签名的工作，其他应用服务在后续的用户请求中不需要(理论上)在询问认证中心，可使用自有的公钥对用户签名进行验证。

### 无状态

你不需要向传统的 Web 应用那样将用户状态保存于 Session 中



## 弊端

- 严重依赖于秘钥：JWT的生成与解析过程都需要依赖于秘钥(Secret)，且都以硬编码的方式存在于系统中(也有放在外部配置文件中的)。如果秘钥不小心泄露，系统的安全性将收到威胁。
- 服务端无法管理客户端的信息：如果用户身份发生异常(信息泄露，或者被攻击)，服务端很难向操作 Session 那样主动将异常用户进行隔离。
- 服务端无法主动推送消息：服务端由于是无状态的，他将无法使用像 Session 那样的方式推送消息到客户端，例如过期时间将至，服务端无法主动为用户续约，需要客户端向服务端发起续约请求。
- 冗余的数据开销：一个 JWT 签名的大小要远比一个 Session ID 长很多，如果你对有效载荷(payload)中的数据不做有效控制，其长度会成几何倍数增长，且在每一次请求时都需要负担额外的网络开销。
- JSON Web Token 很流行，但是它相比于 Session,OIDC(OpenId Connect)等技术还比较新，支持 JSON Web Token 的库还比较少，而且 JWT 也并非比传统 Session 更安全，他们都没有解决 CSRF 和 XSS 的问题。因此，在决定使用 JWT 前，你需要仔细考虑其利弊。

## 如果客户端的 JWT 令牌泄露或者被盗取，会发生什么严重的后果？有什么补救措施？

1. 清除已泄露的令牌：此方案最直接，也容易实现，你需将 [JWT](https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247485197&idx=1&sn=5f2358b0cdb45da37529f925253f8b76&scene=21#wechat_redirect) 令牌在服务端也存储一份，若发现有异常的令牌存在，则从服务端令牌列表中将此异常令牌清除。当用户发起请求时，强制用户重新进行身份验证，直至验证成功。对于服务端的令牌存储，可以借助 Redis 等缓存服务器进行管理，也可以使用 Ehcache 将令牌信息存储在内存中。
2. 敏感操作保护：在涉及到诸如新增，修改，删除，上传，下载等敏感性操作时，定期(30分钟，15分钟甚至更短)检查用户身份，如手机验证码，扫描二维码等手段，确认操作者是用户本人。如果身份验证不通过，则终止请求，并要求重新验证用户身份信息。
3. 地域检查：通常用户会在一个相对固定的地理范围内访问应用程序，可以将地理位置信息作为一个辅助来甄别用户的 [JWT](https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247485197&idx=1&sn=5f2358b0cdb45da37529f925253f8b76&scene=21#wechat_redirect) 令牌是否存在问题。如果发现用户A由经常所在的地区 1 变到了相对较远的地区 2 ，或者频繁在多个地区间切换，不管用户有没有可能在短时间内在多个地域活动(一般不可能)，都应当终止当前请求，强制用户重新进行验证身份，颁发新的 [JWT](https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247485197&idx=1&sn=5f2358b0cdb45da37529f925253f8b76&scene=21#wechat_redirect) 令牌，并提醒(或要求)用户重置密码。
4. 监控请求频率：如果 [JWT](https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247485197&idx=1&sn=5f2358b0cdb45da37529f925253f8b76&scene=21#wechat_redirect) 密令被盗取，攻击者或通过某些工具伪造用户身份，高频次的对系统发送请求，以套取用户数据。针对这种情况，可以监控用户在单位时间内的请求次数，当单位时间内的请求次数超出预定阈值值，则判定该用户密令是有问题的。例如 1 秒内连续超过 5 次请求，则视为用户身份非法，服务端终止请求并强制将该用户的 [JWT](https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247485197&idx=1&sn=5f2358b0cdb45da37529f925253f8b76&scene=21#wechat_redirect) 密令清除，然后回跳到认证中心对用户身份进行验证。
5. 客户端环境检查：对于一些移动端应用来说，可以将用户信息与设备(手机,平板)的机器码进行绑定，并存储于服务端中，当客户端发起请求时，可以先校验客户端的机器码与服务端的是否匹配，如果不匹配，则视为非法请求，并终止用户的后续请求。



## 注销问题

先看传统的session是怎么注销的：用户点击退出，调用后台退出接口，也就是session注销接口，依托于后台的状态更新。那么服务端做的呢，如果是用文件或者数据库存储的，那么通过删记录是可以后台强制踢出的，放在内存里就不要想了（如果用户量大了放内存的话服务器也吃不消，放文件里io太频繁基本也不靠谱，还好有了Redis）。jwt最大的问题就在于后台没有存储用户状态，用户退出的话只是客户端删掉了token，然而此token在有效期内还是有效的，也就是说如果token泄露的话就麻烦了，不过token泄露的问题已经在上面讲过了，和cookie是同一个问题。那么最麻烦的就是怎么让一个token在用户注销后失效，以及后台强制退出，这个jwt是没办法的，因为jwt的无状态和用户状态维护是个矛盾冲突的话题。如果要解决就要建立一个黑名单，也就是把用户注销后的token放到redis里，然后每次校验黑名单（这里还是用到了数据库）

















































