![](https://ws1.sinaimg.cn/large/006tNc79ly1fzfakd2c7jj30mk07eaa9.jpg)

JavaScript使用`Number`类型表示数字（整数和浮点数），遵循 IEEE 754 标准 通过64位来表示一个数字. 数字在内存中的表示如下图:

![](https://ws1.sinaimg.cn/large/006tNc79ly1fzfalk4f57j30u00c8gm4.jpg)

- 第0位：符号位，0表示正数，1表示负数(s)
- 第1位到第11位：储存指数部分（e）
- 第12位到第63位：储存小数部分（即有效数字）f



## 运算时发生了什么

### 进制转换

0.1 和 0.2 转换成二进制后会无限循环

```
0.1 -> 0.0001100110011001...(无限循环)
0.2 -> 0.0011001100110011...(无限循环)
```

但是由于 IEEE 754 尾数位数限制，需要将后面多余的位截掉

这样在进制之间的转换中精度已经损失

这里还有一个小知识点

**那为什么 x=0.1 能得到 0.1？**

这是因为这个 0.1 并不是真正的 0.1。这不是废话吗？别急，听我解释

标准中规定尾数f的固定长度是 52 位，再加上省略的一位，这53位是JS精度范围。它最大可以表示 2^53(9007199254740992), 长度是 16，所以可以使用`toPrecision(16)`来做精度运算，超过的精度会自动做凑整处理.这个就是为什么0.1可以等于0.1的原因

```js
0.10000000000000000555.toPrecision(16)
// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1

// 但来一个更高的精度：
0.1.toPrecision(21) = 0.100000000000000005551
```

### 对阶运算

由于指数位数不相同，运算时需要对阶运算 这部分也可能产生精度损失

按照上面两步运算（包括两步的精度损失），最后的结果是

```
0.0100110011001100110011001100110011001100110011001100 

```

结果转换成十进制之后就是 0.30000000000000004，这样就有了前面的“秀”操作：`0.1 + 0.2 != 0.3`

所以：**精度损失可能出现在进制转化和对阶运算过程中**，只要在这两步中产生了精度损失，计算结果就会出现偏差



## 解决精度问题

### **Math.js**

https://github.com/josdejong/mathjs

### **big.js**

https://github.com/MikeMcl/big.js



























