意向锁相互兼容

1、表明“某个事务正在某些行持有了锁、或该事务准备去持有锁”

2、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存，。

3、例子：事务A修改user表的记录r，会给记录r上一把行级的排他锁（X），同时会给user表上一把意向排他锁（IX），这时事务B要给user表上加一个表级的排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。



**4、1）意向共享锁（IS锁）：事务在请求S锁前，要先获得IS锁
2）意向排他锁（IX锁）：事务在请求X锁前，要先获得IX锁**



**q1：为什么意向锁是表级锁呢？**
当我们需要加一个排他锁时，需要根据意向锁去判断表中有没有数据行被锁定（行锁）；

（1）如果意向锁是行锁，则需要遍历每一行数据去确认；

（2）如果意向锁是表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能。



q2：意向锁怎么支持表锁和行锁并存？
（1）首先明确并存的概念是指数据库同时支持表、行锁，而不是任何情况都支持一个表中同时有一个事务A持有行锁、又有一个事务B持有表锁，因为表一旦被加上了一个表级的写锁，肯定不能再上一个行级的锁。
（2）如果事务A对某一行上锁，其他事务就不可能修改这一行。这与“事务B锁住整个表就能修改表中的任意一行”形成了冲突。所以，没有意向锁的时候，让行锁与表锁共存，就会带来很多问题。于是有了意向锁的出现，如q1的答案中，数据库不需要在检查每一行数据是否有锁，而是直接判断一次意向锁是否存在即可，能提升很多性能。



## **意向锁和共享锁、排他锁的兼容关系**

![](https://youpaiyun.zongqilive.cn/image/20200704100457.png)

意向锁相互兼容，因为IX、IS只是表明申请更低层次级别元素（比如 page、记录）的X、S操作。

因为上了表级S锁后，不允许其他事务再加X锁，所以表级S锁和X、IX锁不兼容

上了表级X锁后，会修改数据，所以表级X锁和 IS、IX、S、X（即使是行排他锁，因为表级锁定的行肯定包括行级速订的行，所以表级X和IX、行级X）不兼容。

注意：上了行级X锁后，行级X锁不会因为有别的事务上了IX而堵塞，一个mysql是允许多个行级X锁同时存在的，只要他们不是针对相同的数据行。











意向锁是InnoDB用来实现各种粒度的锁之间共存的方案。

它作用在**表级别**，表示事务下一步将继续获取记录级别的排他锁，或共享锁。

这样当其他操作需要取得表锁的时候，可以直接根据表上的意向锁来判断是否需要等待。

有两种意向锁：

1. `Intention Shared Lock`共享意向锁(IS)

   事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁

2. `Intention Exclusive Lock`排他意向锁(IX)

   事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁。

意向锁和意向锁之间不会有冲突，因为作用在表级别，所以只有与表级别的共享或排他锁才会发生冲突。从而达到了记录锁与表锁能快速相互感知相互影响的目的。

意向锁其实不会阻塞全表扫描之外的任何请求，它们的主要目的是为了表示**是否有人请求锁定表中的某一行数据**。



![](https://youpaiyun.zongqilive.cn/image/006tKfTcly1g14k6ihtxpj30u00p0mxn.jpg)







意向锁是由数据引擎自己维护的, 无法手动操作意向锁

## 意向共享锁(IS)

`Intention Share Locks`

表示事务准备给数据行加入共享锁, 也就是说一个数据行加共享锁前必须先取的该表的IS锁



## 意向排它锁(IX)

`Intention Exclusive Locks`

表示事务准备给数据行加入排它锁, 说明事务在一个数据行加排它锁前必须先取的该表的IX锁



## 为什么需要表级别的意向锁呢?

一个事务给一张表成功加上表锁的前提:  就是没有其他的任何一个事务已经锁定了其中的任意一行数据. 免去了检索数据的消耗.

























