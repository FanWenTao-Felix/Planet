PHP的数组结构，其内部是使用hashTable结构来实现的，所以我们在php的源码中没有看到zend_array文件，而是zend_hash.h和zend_hash.c两个入口文件。

HashTable主要分为两个环节：

1. 哈希函数：哈希函数将要查找的值转换成数字索引，通过数字索引可以快速的找到值存在的位置。

2. 哈希碰撞：理想情况下，不同的值通过哈希函数后，出来的结果是不一样的；如果不一样的值，哈希后出来一样的数字，我们称之为哈希碰撞；因此HashTable必须要解决哈希碰撞，主要有两种：链表法，开放寻址法。

简单介绍下链表法和开放寻址法：

链表法：当遇到hash的key有冲突的时候，就在对应的数组元素后，挂一个链表，如上图。

开发寻址法：当遇到hash的key有冲突的时候，会去寻找下一个数组元素，如果下一个元素是空的，则占用；如果被占用，则继续寻找下一个元素，直到找到空闲的元素



## PHP数组结构变迁

### php5.6数组结构

![eSqe9H.png](https://s2.ax1x.com/2019/07/21/eSqe9H.png)

数组本质就是一个hashtable结构，左侧的0~nTablemask便是hash下标，而后面有一个双向链表，便是我们通常所说的hash冲突的链地址法。

绿色的双向链表，则是foreach遍历用的，这个地方用双向链表，主要是为了逆序访问来用的，遍历的时候，就是从pListHead开始不断的next便可以遍历所有的元素。这样要比下标遍历hashtable快得多。

但是这个结构有很明显的缺点：

①. 每次插入/删除元素都要申请/释放内存，这样会严重的导致内存碎片化，降低内存的使用率。

②. 再者，每次插入元素的时候都要去申请内存，会有一次寻址的过程，时间效率低。

③. 指针结构很复杂，有大量的指针操作。



### php7.0数组结构

为了实现 HashTable 的有序性，PHP 为其增加了一张**中间映射表**，该表是一个大小与 Bucket 相同的数组，数组中储存整形数据，用于保存元素实际储存的 Value 在 Bucekt 中的下标。

注意，加入了中间映射表后，**Bucekt 中的数据是有序的，而中间映射表中的数据是无序的**。这样顺序读取时只需要访问 Bucket 中的数据即可。

下边的2张图表示的意思差不多: 

![eSjaJU.png](https://s2.ax1x.com/2019/07/21/eSjaJU.png)

![eSxuvQ.png](https://s2.ax1x.com/2019/07/21/eSxuvQ.png)



zend_array 中并没有单独定义中间映射表，而是将其与 arData 放在一起，数组初始化时并不只分配 Bucket 大小的内存，同时还会分配相同大小空间的数据来作为中间映射表，其实现方式如图：

![eSjIOA.png](https://s2.ax1x.com/2019/07/21/eSjIOA.png)

## 散列冲突

不同键名的哈希值通过散列计算得到的「映射表」下标有可能相同，此时便发生了散列冲突。对于这种情况 PHP 使用了「链地址法」解决。下图是访问发生散列冲突的元素的情况：

![eSxdKJ.png](https://s2.ax1x.com/2019/07/21/eSxdKJ.png)

这看似与第一张图差不多，但我们同样访问 `$a['key']` 的过程多了一些步骤。首先通过散列运算得出映射表下标为 -2 ，然后访问映射表发现其内容指向 `arData` 数组下标为 1 的元素。此时我们将该元素的 `key` 和要访问的键名相比较，发现两者并不相等，则该元素并非我们所想访问的元素，而元素的 `val.u2.next` 保存的值正是下一个具有相同散列值的元素对应 `arData` 数组的下标，所以我们可以不断通过 `next` 的值遍历直到找到键名相同的元素或查找失败。















