https://juejin.im/post/6844903817713025032#heading-2

## 业界解决方案

#### 扫表

- 扫表一整张表需要一段时间，会造成任务的触发有延时，有的时候一个进程每个还要扫多个表；
- 扫表不可能太频繁，因为太频繁会对数据库造成太大压力，每隔一段较长的时间才能再扫一遍，这个时间间隔一般至少在一分钟以上。这也会造成任务延时；
- 扫表扫的是从库，而主从同步存在延时。特别是当大事务出现时，会导致几分钟甚至几小时的延时；
- 扫表的方法很笨重，每次扫描一整张表而实际需要触发的任务可能没几个，资源利用很低下；

扫表最大的问题就是会有延迟，不能再指定的时间里触发，对于时效性高的场景，这种方案是不能满足需求的。

 

#### 延时消息队列

而且该方案也存在一个瓶颈就是如果，延时任务需要重新更新时间就做不到了，因为消息已经发出去了，收不回了。



#### 时间片轮询

用环形队列做成时间片，环形队列的每个格子里维护一个链表。每个时刻有一个当前指针指向环形队列某个格子，定时器每超时一次，就把当前指针指向下环形队列的下一个格子。然后处理这个格子保存的链表里的任务。如果只是这样维护，如果要做到秒级的粒度，时间长度最长一天，那么这个环形队列就会非常大。因此，有人又有人改进了一下，当存在任务进入队列时，就用时间长度除以环形队列的长度，记为圈数。这样每次遍历到该元素时，将圈数减一，如果减一后为0就执行改任务，否者不执行。

kafka的延时消息的内部实现就是采用时间片轮询的方式来实现的。

对于时间跨度非常大的场景，如果使用这种方法会导致链表上的元素非常多，遍历链表的开销也不小，甚至在一个时间片内遍历不完。因此，又有了进一步的改进，将时间片分为不同粒度的。比如，粒度为小时的时间轮，粒度为分钟的时间轮，粒度为秒钟的时间轮。小时里的时间轮达到触发的条件后会放到分钟的时间轮里，分钟的时间轮到达触发的条件后会放到秒的时间轮里

 ![](https://youpaiyun.zongqilive.cn/image/20201114173007.png)

该方案时间片存放在内存，因此轮询起来效率非常高，也可以根据不同的粒度调整时间片，因此也非常灵活。但是该方案需要自己实现持久化与高可用，以及对储存的管理，如果没有现成的轮子开发耗时会比较长。



#### Redis的ZSET实现

用`ZRANGEBYSCORE key -inf +inf limit 0 1 withscores`命令来实现

说明：

- 为了避免一个key存储在数据量变多以后，首先会导致查询速度变慢，因为其时间复杂度为O(logN)，其次如果在同一个时间点有多个任务时，一个key会分发不过来，造成拥堵。因此，我们将其设计为多个key来存储，通过uuid进行hash路由到对应的key中，如果任务量增长，我们可以快速扩容redis key的数量来抗住增长的数量；
- 建立与多个key相同的进程或者线程数，每个进程一个编号，分别对应一个key，不断轮询相应的key；
- 轮询key的进程我们将其称为event进程，event进程只查询出任务，但是不处理业务，将该任务写入到消息队列中。另外有work进行从消息队列取消息，然后执行业务。这样work进行可以分布式部署，event进行只需做分发，这样可以把并发做到非常高，即使同一时间有大量的任务，也能很小的延时内完成任务；
- 为了避免event进程单机部署，在机器宕机后导致无法取消息，redis储存的数据还会被积压。我们多机部署event进程，并使用zookeeper选主，只有leader主机上的进程才从redis取消息。leader主机宕机后，zookeeper会自动选择新的leader；
- 在实际的业务中，还依赖DB写入数据。延时任务产生是先修改DB然后再向redis写入数据，那么就存在DB更新成功，然后redis写失败的场景，这个时候首先是通过重试来减少redis写入失败的概率，如果重试任然不能成功，就发送一条消息给daemon进程进行异步补偿；

 ![](https://youpaiyun.zongqilive.cn/image/20201114173150.png)





















