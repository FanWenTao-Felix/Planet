在java8中, 得益于`Lambda`所带来的函数式编程, 引入了一个全新的`Stream`概念,用于解决已有集合类库既有的弊端



`Stream(流)`是一个来组数据源的元素队列

- 元素式特定类型的对象, 形成一个队列, java中的`Stream`并不会存储元素, 而是按需计算
- 数据源流的来源: 可以是集合, 数组等

和之前的`Collection`操作不同, `Stream`操作还有两个基础的特征:

- `Pipelining`: 中间操作都返回流对象本身, 这样多个操作,可以串成一个管道. 这样操作可以对象进行优化, 比如`延迟执行(laziness)`和`短路(short-circuiting)`
- 内部迭代: `Sreeam`提报了内部迭代的方式, 流可以直接遍历方法.

## 代码示例

例如对集合进行过滤:

传统方式:

![](https://pic.superbed.cn/item/5e0954c276085c3289a1141c.jpg)

`Stream流`的方式:

![](https://pic.superbed.cn/item/5e0954ec76085c3289a11b3c.jpg)

## 流式思想概述

![](https://pic.superbed.cn/item/5e09551f76085c3289a123a9.jpg)

上图中展示了过滤, 映射, 跳过, 计数等多步操作, 这是一种集合元素的处理方案, 而方案就是一种`函数模型`.

图中的每一个方框都是一个`流`, 调用指定的方法, 可以从一个流模型转换为另一个流模型, 而最右侧的数字3是最终结果.

这是的`filter`,`map`,`skip`都是在对函数模型进行操作, 集合元素并没有真正被处理, 只有当终结方法`count`执行的时候, 整个模型才会按照指定策略执行操作. 这得益于`Lambda延迟执行`特征.





























































