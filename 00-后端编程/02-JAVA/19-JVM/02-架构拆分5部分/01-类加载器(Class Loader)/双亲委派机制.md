Java虛拟机对class文件采用的是**按需加载**的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java 虚拟机采用的是双亲委派模式，即把请求交由上层加载器处理，它是一种任务委派模式。

![](https://youpaiyun.zongqilive.cn/image/20200319154650.png)



当一个类收到了类加载请求, 首先不会尝试自己去加载这个类, 而是把这个请求委派给父类去完成, 每一个层次类加载器都是如此, 因此所有的加载请求都应该是传到启动类加载器(`BootstrapClassLoader`)中, 只有当父类加载器反馈自己无法完成这个请求的时候(在它的加载路径下没有找到所需加载的class), 子类加载器才会尝试自己去加载

![](https://youpaiyun.zongqilive.cn/image/20200318112155.png)

![](https://youpaiyun.zongqilive.cn/image/20200319153437.png)



“双亲委派”机制，保证“沙箱安全”。即先找到先使用。

这时通常会将加载请求顺序委派到最上层加载器（引导类加载器），如果引导类加载器可以加载，则加载指定目录下的类，如果不能加载，则会由下层加载器逐层加载。



## 优势

![](https://youpaiyun.zongqilive.cn/image/20200319154920.png)



采用双亲委派的一个好处是:  比如加载位于`rt.jar`包中的类`java.lang.Object`, 不管是哪个加载器加载这个类, 最终都是委托给顶层的启动类加载器进行加载, 这样就保证了使用不用的类加载器最终得到的都是同样一个`Object`对象



> 双亲委派机制：“我爸是李刚，有事找我爹”。
>
>  例如：需要用一个A.java这个类，首先去顶部Bootstrap根加载器去找，找得到你就用，找不到再下降一层，去Extension加载器去找，找得到就用，找不到再将一层，去AppClassLoader加载器去找，找得到就用，找不到就会报"CLASS NOT FOUND EXCEPTION"。
>









































































































