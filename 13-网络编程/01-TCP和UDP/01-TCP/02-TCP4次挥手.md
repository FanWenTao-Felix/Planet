![Zz0lhd.png](https://s2.ax1x.com/2019/07/20/Zz0lhd.png)





第一次挥手:

Client发送一个FIN, 用来关闭CLient到Server的数据传递, Client进入FIN_WAIT_1状态

第二次挥手: 

Server收到FIN后, 发送ACK给Client, 确认序号维收到的序号+1,  Server进入CLOSE_WAIT状态

第三次挥手:

Server发送一个FIN, 用来关闭Server到Client的数据传递, Server进入LAST_ACK状态

第四次挥手:

Client收到FIN后, Client进入TIME_WAIT状态, 接着发送一个ACK给Server, 确认序号为收到的序号+1, Server进入CLOSE状态, 完成四次挥手



## 为什么需要TIME_WAIT

 **是谁有TIME_WAIT状态呢？为什么？**

​        **执行主动关闭的那一端、因为可能不得不重传最终那个ACK的就是这一端**

**TIME_WAIT有多久呢？**

​        **最长分节生命期的两倍。2MSL。MSL:任何IP数据报能够在因特网上存活的最长时间**

 **什么是迷途的重复分组呢？**

**假设迷途的分组是一个TCP分节，他在迷途期间，发送端TCP超时并重传该分组，而重传的分组却通过某条候选路径到达最终目的地。然后不久后（自迷途的分组开始其迷途旅程起最多MSL）路由循环修复，早先迷失的分组最终也被送到目的地。这样的分组就叫迷途重复分组。**



**TIME_WAIT存在的理由：**

1）可靠地实现TCP全双工连接的终止
    在进行关闭连接四路握手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，服务器将重发最终的FIN，因此客户端必须维护状态信息允 许它重发最终的ACK.

2）允许老的重复分节在网络中消逝  
    TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个 原来的迷途分节就称为lost duplicate。在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，后一个连接被称为前一个连接的化身 （incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免这个情 况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时 候，来自连接先前化身的重复分组已经在网络中消逝。







