开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。



限流是限制系统的输入和输出流量，以达到保护系统的目的，而限流的实现主要是依靠限流算法，限流算法主要有4种：

## 固定时间窗口算法（计数器）



![](https://ae01.alicdn.com/kf/Hcca9c8a884184db2b08cabc2b580cf14d.jpg)

使用redis的incr原子自增性即可轻松实现。

固定窗口计数器算法概念如下：

- 将时间划分为多个窗口;
- 在每个窗口内每有一次请求就将计数器加一;
- 如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃当时间到达下一个窗口时，计数器重置。

固定窗口计数器是最为简单的算法，但这个算法有时会让通过请求量允许为限制的两倍。考虑如下情况：限制1秒内最多通过5个请求，在第一个窗口的最后半秒内通过了5个请求，第二个窗口的前半秒内又通过了5个请求。这样看来就是在1秒内通过了10个请求。

![](https://ae01.alicdn.com/kf/Hf3512dcb11684f1d8c4afe5c7ce1f63bv.jpg)

## 滑动窗口计数器算法

![](https://ae01.alicdn.com/kf/Hae36e980e06e43b1a41a23cc797eb0f70.jpg)

滑动窗口计数器算法概念如下：

- 将时间划分为多个区间;
- 在每个区间内每有一次请求就将计数器加一维持一个时间窗口，占据多个区间;
- 每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间;
- 如果当前窗口内区间的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃。

滑动窗口计数器是通过将窗口再细分，并且按照时间"滑动"，这种算法避免了固定窗口计数器带来的双倍突发请求，但时间区间的精度越高，算法所需的空间容量就越大。

## 漏桶算法

![](https://ae01.alicdn.com/kf/H5969ab655b0f43039f7f4aabd7502c37x.jpg)

漏桶算法概念如下：

将每个请求视作"水滴"放入"漏桶"进行存储;

"漏桶"以固定速率向外"漏"出请求来执行如果"漏桶"空了则停止"漏水";

如果"漏桶"满了则多余的"水滴"会被直接丢弃。

漏桶算法多使用队列实现，服务的请求会存到队列中，服务的提供方则按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。

漏桶算法的缺陷也很明显，当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应。

### 算法特点

1. 因为流出的速度是一定的，可以抵御突发流量，做到更加平滑的限流，而且不允许流量突发。

伪代码:

```
class LeakyDemo {
    public long timeStamp = getNowTime();
    public int capacity; // 桶的容量
    public int rate; // 水漏出的速度
    public int water; // 当前水量(当前累积请求数)

    public boolean grant() {
        long now = getNowTime();
        water = max(0, water - (now - timeStamp) * rate); // 先执行漏水，计算剩余水量
        timeStamp = now;
        if ((water + 1) < capacity) {
            // 尝试加水,并且水还未满
            water += 1;
            return true;
        } else {
            // 水满，拒绝加水
            return false;
        }
    }
}
```

## 令牌桶算法

Google开源项目Guava中的RateLimiter使用的就是令牌桶算法

1. 所有的请求在处理之前都需要拿到一个可用的令牌才会被处理。
2. 根据限流大小，设置按照一定的速率往桶里添加令牌。
3. 桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝。
4. 请求到达后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除。

![](https://ae01.alicdn.com/kf/H229ebe2efd6041cd8de59eeaee924a7ch.jpg)

```
class TokenBucketDemo {
    public long timeStamp = getNowTime();
    public int capacity; // 桶的容量
    public int rate; // 令牌放入速度
    public int tokens; // 当前令牌数量

    public boolean grant() {
        long now = getNowTime();
        // 先添加令牌
        tokens = min(capacity, tokens + (now - timeStamp) * rate);
        timeStamp = now;
        if (tokens < 1) {
            // 若桶中没有令牌,则拒绝
            return false;
        } else {
            // 还有令牌，领取令牌
            tokens -= 1;
            return true;
        }
    }
}
```

### 算法特点

1. 可以抵御突发流量，因为桶内的令牌数不会超过给定的最大值
2. 可以做到更加平滑的限流，因为令牌是匀速放入的。
3. 令牌桶算法允许流量一定程度的突发。（相比漏桶算法）

在时间点刷新的临界点上，只要剩余token足够，令牌桶算法会允许对应数量的请求通过，而后刷新时间因为token不足，流量也会被限制在外，这样就比较好的控制了瞬时流量。因此，令牌桶算法也被广泛使用。

























































