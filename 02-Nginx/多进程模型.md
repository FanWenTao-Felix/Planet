nginx启动后, 后台模式运行, 包含一个master进程和多个worker进程。

当然, 我们也可以手动地关掉后台模式，让nginx在前台运行，并且通过配置让nginx取消master进程，从而可以使nginx以单进程方式运行。所以关闭后台模式，一般是用来调试用的.

master:

master进程主要用来管理worker进程，具体包括如下4个主要功能：
（1）接收来自外界的信号。
（2）向各worker进程发送信号。
（3）监控woker进程的运行状态。
（4）当woker进程退出后（异常情况下），会自动重新启动新的woker进程。

woker:

基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。



## worker进程的数量设置

worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。更多的worker数，只会导致进程来竞争cpu资源了，从而带来不必要的上下文切换。而且，nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。

- 尽可能限制工作进程的数量，从而减少上下文切换带来的开销。默认和推荐配置是让每个CPU内核对应一个工作进程，从而高效利用硬件资源。
- 工作进程采用单线程，并以非阻塞的方式处理多个并发连接。



nginx的多进程模型，如下图:

![](http://ww3.sinaimg.cn/large/006tNc79ly1g4t7dunf0qj30fu0a6jrj.jpg)



## 如何平滑启动的?

`./nginx -s reload`, 该命令会向master进程发送信号

master进程在接收到信号后是怎么做的呢？首先master进程在接到信号后，会先重新加载配置文件，然后再启动新的worker进程，并向所有老的worker进程发送信号，告诉他们可以光荣退休了。新的worker在启动后，就开始接收新的请求，而老的worker在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。

## 如何保证保证只有一个进程处理该连接?

所有worker进程的listenfd会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有worker进程在注册listenfd读事件前抢accept_mutex，抢到互斥锁的那个进程注册listenfd读事件，在读事件里调用accept接受该连接。当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。

## 好处

1. 对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，
2. 采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险



## 网络事件

采用`异步非阻塞`的方式来处理网络事件, 例如`epoll`





























